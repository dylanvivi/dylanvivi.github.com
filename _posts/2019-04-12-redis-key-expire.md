---
layout : post
category: notes
title : Redis key过期策略
---
Redis所有的数据结构都可以设置过期时间，到期后，key会被自动删除。

Redis key过期的方式有三种：

- 被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key
- 主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key
- 当前已用内存超过maxmemory限定时，触发主动清理策略

### 被动删除

只有key被操作时(如GET)，Redis才会被动检查该key是否过期，过期就删除，并返回NULL。

这种删除策略对CPU友好，不会在删除上浪费无谓的CPU时间。然而这种策略对内存不友好，一个key已经过期，但是在它被操作之前不会被删除，仍然占据内存空间。如果系统中存在大量的不会被访问的数据，就会造成资源浪费。

### 主动删除

Redis会把有过期时间的key放在一个单独的字典里，默认每100ms检查，是否有过期的key，有过期的key则删除。

这里不是每100ms把所有key检查一次，而是随机抽取检查。

典型的方式为，Redis每秒做10次如下的步骤：

	1. 随机测试100个设置了过期时间的key
	2. 删除所有发现的已过期的key
	3. 若删除的key超过25个则重复步骤1

这是一个基于概率的简单算法，基本的假设是抽出的样本能够代表整个key空间，redis持续清理过期的数据直至将要过期的key的百分比降到了25%以下。这也意味着在任何给定的时刻已经过期但仍占据着内存空间的key的量最多为每秒的写操作量除以4。

除了主动淘汰的频率外，Redis对每次淘汰任务执行的最大时长也有一个限定，这样保证了每次主动淘汰不会过多阻塞应用请求。

当Redis启用主从模式时，只有主结点执行上述这两种过期删除策略。主节点在key到期时，会在AOF文件里增加一条del指令，同步到所有的从节点，从节点通过执行这条del指令来删除过期的key。

### 主动清理

当Redis实例的内存超过设置的maxmemory时，会根据配置的策略（maxmemory-policy）来对key进行淘汰，可选的淘汰策略有如下几种：

- noeviction:当内存使用达到阈值的时候，会堵塞所有申请内存的命令，可读，可执行del命令。
- volatile-lru:当内存使用达到阈值的时候，会优先淘汰设置了过期时间且最近最少使用的key，未设置过期时间的key不会被淘汰。
- volatile-ttl:当内存使用达到阈值的时候，会优先淘汰设置了过期时间且剩余过期时间ttl越小的key。
- volatile-random:当内存使用达到阈值的时候，会随机淘汰设置了过期时间key。
- allkeys-lru:当内存使用达到阈值的时候，针对所有的key按照最近最少使用原则进行淘汰。
- allkeys-random:当内存使用达到阈值的时候，针对所有的key随机进行淘汰。

线上的所有Reids实例默认的淘汰策略为volatile-lru。

上述策略可以在 redis.conf 中配置。

## 生成RDB文件时

> 执行 SAVE 或 BGSAVE 时，数据库键空间中的过期键不会被保存在RDB文件中。

## 载入RDB文件时

> Master 载入RDB时，文件中的未过期的键会被正常载入，过期键则会被忽略。
> Slave 载入 RDB 时，文件中的所有键都会被载入，当同步进行时，会和Master 保持一致。

## AOF 文件写入时

> 数据库键空间的过期键的过期但并未被删除释放的状态会被正常记录到 AOF 文件中，当过期键发生释放删除时，DEL 也会被同步到 AOF 文件中去。

## 重新生成 AOF文件时

> 执行 BGREWRITEAOF 时 ，数据库键中过期的键不会被记录到 AOF 文件中

## 复制

> Master 删除 过期 Key 之后，会向所有 Slave 服务器发送一个 DEL命令，从服务器收到之后，会删除这些 Key。

> Slave 在被动的读取过期键时，不会做出操作，而是继续返回该键，只有当Master 发送 DEL 通知来，才会删除过期键，这是统一、中心化的键删除策略，保证主从服务器的数据一致性。

